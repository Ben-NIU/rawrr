---
title: rawR - Technical Note, Journal of Proteome Research, Second Biennial Special
  Issue on Software Tools and Resources in February 2021
author: "Tobias Kockmann^1‡^ & Christian Panse^1,2‡^"
date: "`r Sys.Date()`"
output:
  pdf_document: 
    keep_tex: true
  html_document:
    df_print: paged
  word_document: default
  citation_package: natbib
bibliography: rawR.bib
csl: american-chemical-society.csl
vignette: |
  %\usepackage[utf8]{inputenc}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::knitr} %\VignetteIndexEntry{rawR JPR Technical Note}
  %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

^1^Functional Genomics Center Zurich, ETH Zurich / University of Zurich,
Winterthurerstrasse 190, 8057 Zurich, Switzerland

^2^Swiss Institute of Bioinformatics, Quartier Sorge - Batiment Amphipole,
1015 Lausanne, Switzerland

## Abstract

The Bioconductor project has shown that the R statistical environment is a
highly valuable tool for genomics data analysis
[@Huber2015], but with respect to proteomics
we are still missing low level infrastructure to enable performant and robust
analysis workflows in R. Fundamentally important are libraries that provide
raw data access. Our R package rawDiag [@Trachsel2018]
has provided the proof-of-principle how access to mass spectromerty raw files
can be realized by wrapping vendor-provided APIs. Our novel package rawR now
aims for complete, OS independent access to all spectral, chromatographic and
meta data logged in Thermo Fisher Scientific raw files. rawR interoperates with
other R packages for proteomics data visualisation ([protViz](https://CRAN.R-project.org/package=protViz)) and will ...

**Availability**: <https://github.com/fgcz/rawR>

## Keywords

computational mass spectrometry, software, R package

## Introduction

...


## Implementation

### `C#` code

The `base::system2` R function invokes the `rawR.exe`  .NET application. `rawR.exe` utilizes the NewRawFileReader .Net assembly provided by Thermo Fisher Scientific [@RFR]. 
Therefore, it can read the proprietary vendor files and provide R code for nested S3 class R [@R] objects as output.
`rawR.exe` takes input arguments as the raw file name and option for extracting spectra or chromatographic information. 
The `C#` source code and a precompiled binary is shipped with the released R package and
runs on Linux, Microsoft Windows, and MacOSX on the X86_64 hardware architecture.


### R

Mass spectrometry (MS) uses two basic building blocks (data items): 1. mass spectrum, 2. chromatogram. All mass spectra are recorded by scanning detectors (mass analyzers) that log signal intensities for ranges of mass to charge ratios (m/z), also referred to as position. These recordings can be of continuous nature so called profile data, or appear centroided in case discrete information (tuples of position and intensity values) is sufficient. This heavily compacted data structure is often called a peak list. In addition to signal intensities, peak list can also cover additional attributes like peak resolution, charge, or local noise around the peak. In short, the additional attributes further described the nature of the original profile signal, or help to group peak lists with respect to their molecular nature or processing history. A well-known example is the assignment of peaks to peak groups that constitute isotope patterns (M, M+1, M+2, ...). Chromatograms come in different flavours, but are always signal intensity values as a function of time. Signal intensities can be point estimates from scanning detectors or plain intensities from non scaning detectors (e.g. UV trace). Point estimates can be defined in different ways by for instance summing all signals of a given spectrum (total ion chromatogram or TIC), or by extracting signal around an expected value (extracted ion chromatogram = XIC), or by using the maximum signal (base peak chromatogram = BPC). On top, chromatograms can be computed from pre-filtered lists of scans. A total ion chromatogram (TIC) for instance is typically generated by iterating over all MS1-level scans. 

We therefore decided to implemented objects in R that closely resemble these basic building blocks. The spectrum object is technically a nested list (S3 class system). Apart from the peak list the spectrum object also stores meta information on how the scan was recorded and how it relates to other scans in the raw file. This meta information is grouped for better transparency. The chromatogram object ...


### Example data

<!---
TODO(cp): add to man page
The binary example file sample.raw contains 574 fourier-transformed orbi trap spectra (FTMS) recorded on a Thermo Fisher Scientific Q Exactive HF-X. The mass spectrometer was operated in line with a nano electrospray source (NSI) in positive mode (+). All spectra were written to disk after applying centroiding (c) and lock mass correction. Additional raw data for demonstration and extended testing is available through the [tartare package](https://bioconductor.org/packages/tartare/). Lions love raw meat!
-->

## Results



|function|description|
|--------|-----------|
|readFileHeader|extracts some meta information from a given rawfile.|
|readIndex|read scan index|
|readSpectrum|reads scan information, e.g., charge, mZ, or intensity of a given set of scan numbers using a dot net interface and the ThermoFisher NewRawFileReader libraries.|
|readChromatogram|extracts Chromatogram|


### Use Case I - Analyzing orbi trap spectra
<!---
scp fgcz-r-035.uzh.ch:/export/lv_iduzh06/projects/p1000/Proteomics/QEXACTIVEHF_2/tobiasko_20181113/20181113_010_autoQC01.raw ~/Downloads/

http://fgcz-ms.uzh.ch/~cpanse/20181113_010_autoQC01.raw
MD5: (20181113_010_autoQC01.raw) = a1f5df9627cf9e0d51ec1906776957ab

-->

The orbitrap detector has been a tremendous success story in MS, since it offers high resolution, accurate mass (HR-AM) data on a time scale that is compatible with chromatographic analysis (LC-MS). It is therefore heavily used for bottom-up proteomics, but analyzing orbitrap data in `R` has so far only been possible after raw data transformation to exchange formats like mz(X)ML. This use case shows how easy it is to work directly with the binary raw data, after installing our R package `rawR` that applies vendor APIs for data access. For demonstration purposes we use a complete LC-MS run recorded on a

```{r, echo=FALSE}
library(rawR)
rawfile <- file.path(Sys.getenv('HOME'), "Downloads", "20181113_010_autoQC01.raw")
H <- rawR::readFileHeader(rawfile = rawfile)
H$`Instrument model`
```
The
```{r, echo=FALSE}
H$`Time range`[2]
```

min run resulted in 
```{r, echo=FALSE}
H$`Number of scans`
```

scans that were written to disc. Already typing the above lines uses `rawR` functionality, since the instrument model, the time range of data acquisition, and the number of scans is extracted from the binary file header. The respective function is called `readFileHeader()` and returns a simple `R` object of type `list`.

Individual scans or collection (sets) of scans can be read by the function `readSpectrum()` which returns a `rawRspectrum` object or `rawRspectrumSet`. Our package of course also provides generics for printing and plotting these objects. The following code chunk depicts how a set of scans is read from the rawfile and the corresponding Fig. 1 shows the resulting plot for scan 9594:

cite [@protViz]

```{r plot.rawRspectrum, fig.cap="Plot of scan number 9594 showing a centroided tandem mass spectrum of the iRT peptide precursor LGGNEQVTR++ in positive mode. The scan was acquired on an orbitrap detector incl. lock mass correction and using a transient of 64 ms (equal to a resolving power of 30'000 at 200 m/z) and injection of 100'000 charges (AGC target). Peak attributes like m/z, charge (z), and resolution (R) are shown above the peaks.", error=TRUE}
library(rawR)
rawfile <- file.path(Sys.getenv('HOME'), "Downloads", "20181113_010_autoQC01.raw")
## scan numbers (PSMs) derived from DB search
i <- c(9594, 11113, 11884, 12788, 12677, 13204, 13868, 14551, 16136, 17193, 17612)
S <- rawR::readSpectrum(rawfile = rawfile, scan = i)
class(S[[1]])
print(S[[1]]) #comment this line if necessary to save space

plot(S[[1]], centroid=TRUE)
```

The plot shows typical orbitrap peak attributes like resolution (R) and charge (z) above the most intense peaks when centroided data is available and selected. Centroided data also makes it possible to graph spectra using signal-to-noise as response value. This is potentially interesting, since orbitrap detectors follow $$S/N \propto charges \cdot \sqrt R$$ and signal-to-noise makes judging the signal quantity more intuitive than using arbitrary signal intensity units. Fig. 2 shows that all fragment ion signals are several ten or even hundred fold above the local noise estimate.

```{r, eval = TRUE, fig.cap = "Spectrum plot using Signal/Noise option. The vertical grey lines indicate the *in-silico* computed y-ions of the peptide precusor LGGNEQVTR++."}
plot(S[[1]], centroid=TRUE, SN = TRUE)

## S/N threshold indicator
abline(h = 5, lty = 2, col = "blue")

## decorate plot with y-ion series of target peptide
yIonSeries <- c(175.1190, 276.1666, 375.2350, 503.2936, 632.3362, 746.3791,
                803.4006, 860.4221)
names(yIonSeries) <- paste0("y", seq(1, length(yIonSeries)))
abline(v = yIonSeries, col='#DDDDDD88', lwd=5)
axis(3, yIonSeries, names(yIonSeries))
```


More sophisticated analysis workflows applying `rawR` functionality have been described in [@Gehrig2020]. In short, marker ions found in HCD MS2 spectra for ADP-ribosylated peptides were annotated and cross compared at different collision energies. You may have notices that such things become relatively simple, since the `rawRspectrum` object provides easy access to normalized and absolute collision energies. A small molecule application using UVPD dissociation is described in [@Panse2020]. 


### Use Case II - iRT regression for system suitability monitoring

By applying linear regression one can convert observed peptide retention times (RTs) into dimensionless scores termed iRT values (iRTs) and *vice versa* [@Escher2012]. This can be used for retention time calibration/prediction. In addition, fitted iRT regression models provide highly valuable information about LC-MS run performance. In this example we show how easy it is to perform iRT regression in `R` by just using the raw measurement data, our package `rawR`, and well known `base R` functions supporting linear modeling. To get a first impression of the data we calculate a TIC using the `readChromatogram()` function. Plotting the TIC shows chromatographic peaks between 15 and 28 min that could be of peptidic origin (Hint: There is also a `type = "bpc"` option if your prefer a BPC):

```{r TIC, fig.cap="TIC"}
plot(rawR::readChromatogram(rawfile = rawfile, type = "tic"))
```

```{r BPC, fig.cap="BPC", eval=FALSE}
plot(rawR::readChromatogram(rawfile = rawfile, type = "bpc"))
```

The initial step of iRT regression is now to estimate the empirical RTs of a peptide set with known iRT scores. In the simplest case, this is achieved by computing an extracted ion chromatogram (XIC) for iRT peptide precursors, given they were spiked into the sample matrix prior to data acquisition. Luckily ;-), our example data is iRT peptides in a tyrptic digest of BSA. The code chunk below demonstrates how the function `readChromatogram()` is called on the R command line to return a `rawRchromatogramSet` object of the type `xic`. This object is plotted for visual inspection. 

```{r plot.rawRchromatogram, fig.cap="XICs for iRT peptides precursors. Each XIC was calculated using a tolerance of 10 ppm around the target mass and using only MS1 scans.", error=TRUE}
iRT <- c(487.2571, 547.2984, 622.8539, 636.8695, 644.8230, 669.8384, 683.8282,
            683.8541, 699.3388, 726.8361, 776.9301)

names(iRT) <- c("LGGNEQVTR", "YILAGVENSK", "GTFIIDPGGVIR", "GTFIIDPAAVIR",
                 "GAGSSEPVTGLDAK", "TPVISGGPYEYR", "VEATFGVDESNAK",
                 "TPVITGAPYEYR", "DGLDAASYYAPVR", "ADVTPADFSEWSK",
                 "LFLQFGAQGSPFLK")

C <- rawR::readChromatogram(rawfile, mass = iRT, tol = 10, type = "xic", filter = "ms")
plot(C, diagnostic = TRUE)
```

Be reminded that the intensity traces are not computed within `R` for instance by reading all scans of a raw file and subsequently iterating over a scan subset (This would be a greedy, but slow solution!). Instead, traces are directly calculated by a `C#` method (reference method code) that calls the vendor API. The API takes care of the filtering process (checks filter validity and applies the filter). On the `R` level there is no need to know *a priori* which scans match the filter rule, or implement vectorized operations (we generate multiple XICs simultaneously here). Only the API-returned output needs to be parsed into `rawRchromatogram` objects. By changing the filter, one can easily switch between generating precursor traces and fragment ion traces. The following code chunk shows how to create fragment ion chromatograms (y6 to y8) generated from scans that target LGGNEQVTR++:

```{r fragmentIonTraces, fig.cap="XICs for LGGNEQVTR++ fragment ions y6 to y8"}
plot(rawR::readChromatogram(rawfile = rawfile,
      mass = yIonSeries[c("y6", "y7", "y8")],
      type = 'xic', tol = 10,
      filter = "FTMS + c NSI Full ms2 487.2567@hcd27.00 [100.0000-1015.0000]"))
```

You will immediately recognize that this means our example data was actually recorded using parallel reaction monitoring (PRM), since 487.2567 was targeted in regular spaced intervals. You could confirm this by using the `readIndex()` function which returns a `data.frame` that indexes all scans found in a raw file and subsetting it for the scans of interest. The delta between consecutive scans is always 22 scans:


```{r}
I <- rawR::readIndex(rawfile = rawfile)
head(subset(I, scanType == "FTMS + c NSI Full ms2 487.2567@hcd27.00 [100.0000-1015.0000]"))
```

For regression, we now extract the RTs at the maximum of the intensity traces stored in the chromatogram object and fit a linear model of the form: $$rt = a + b\cdot score$$ In theory, we could do this at the precursor or fragment ion level. For simplicity we show only the first option.  

```{r iRTscoreFit, error=TRUE}
score <- c(-24.92, 19.79, 70.52, 87.23, 0, 28.71, 12.39, 33.38, 42.26, 54.62, 100)
rt <- sapply(C, function(x) x$times[which.max(x$intensities)[1]])
fit <- lm(rt ~ score)
```


The fitted model can than be inspected using std. procedures. Code chunk `iRTscoreFitPlot` shows a visual inspection by plotting observed RTs as a function of iRT score together with the  fitted model regression line. The corresponding R squared indicates that the RTs behave highly linear! This is expected since, the iRT peptides were separated on a 20 min linear gradient from 5 %B to 35 %B using C18 RP material (the change rate is therefore 1.5 %B / min). The magnitude of the slope parameter (b) is a direct equivalent of this gradient change rate. The intercept (a) is equal to the predicted RT of iRT peptide GAGSSEPVTGLDAK, since it was defined to have a zero score on the iRT scale.


```{r iRTscoreFitPlot, echo=FALSE, error=TRUE, fig.cap="iRT regression"}
plot(rt ~ score,
     ylab = 'Retention time [min]',
     xlab = "iRT score",
     pch=16,frame.plot = FALSE)
abline(fit, col = 'grey')
abline(v = 0, col = "grey", lty = 2)
legend("topleft", legend = paste("Regression line: ", "rt =",
                                 format(coef(fit)[1], digits = 4), " + ",
                                 format(coef(fit)[2], digits = 2), "score",
                                 "\nR2: ", format(summary(fit)$r.squared, digits = 2)),
       bty = "n", cex = 0.75)
text(score, rt,  iRT,pos=1,cex=0.5)
```

We (the FGCZ) use these iRT regression models to automatically monitor the performance of our LC-MS systems on a longitudinal level. The basic idea is that parameter estimates from individual raw files should behave like a random variable.


## Conclusions

... next 

- [@Schmidt2020] 
- [@biocspectra] The wrapper can benefit from Rs multicore utilities [Figure 3,@Trachsel2018]. 


## Author information

### Corresponding author

Tobias Kockmann  
E-mail: <tobias.kockmann@fgcz.ethz.ch>

### ORCID

Christian Panse <https://orcid.org/0000-0003-1975-3064>  
Tobias Kockmann <https://orcid.org/0000-0002-1847-885X>  

### Author contributions

The manuscript was written through contributions of all authors. All authors have given approval to the final version of the manuscript. ‡These authors contributed equally.


## Funding Sources

Any funds used to support the research of the manuscript should be placed here (per journal style).


## Acknowledgements

We thank Lilly van de Venn for designing the rawR package logo.


## Abbreveations

MS, mass spectromerty; TIC, total ion chromatogram;
XIC, extracted ion chromatogram; fourier-transformed mass spectrum (FTMS);
nano spray ionisation, NSI;

# References
<div id="refs"></div>

# Appendix

```{r monoInfo, message=TRUE, echo=TRUE}
system2("mcs", "--version", stdout = TRUE)
system2("mono", "-V", stdout = TRUE)
```

```{r sessionInfo}
sessionInfo()
```
