.monoInfo <-function(){
    # system2("mcs", "--version", stdout = TRUE)
    system2("mono", "-V", stdout = TRUE)
}


.writeRData <- function(rawfile, outputfile=paste0(rawfile, ".RData"), tmpdir=tempdir()){
    
    scanRange <- readFileHeader(rawfile)$`Scan range`
    scanIdx <- seq(scanRange[1], scanRange[2], by=1)
    
    res <- lapply(scanIdx, function(x){
        rv <- readSpectrum(rawfile, scan=x, tmpdir=tmpdir)[[1]]
        list(scanType=rv$scanType, mZ=rv$mZ, intensity=rv$intensity, charge=rv$charge, rtinseconds=rv$rtinseconds)
    })
    e <- new.env()
    objName <- paste("S",basename(rawfile), sep='')
    assign(objName, res, envir = e)
    
    save(objName, file=outputfile, envir = e)

} 

.isMonoAssemblyWorking <- 
    function(exe = file.path(path.package(package = "rawR"), "exec", "rawR.exe")){
        if(Sys.info()['sysname'] %in% c("Darwin", "Linux")){
            if (Sys.which('mono') == ""){
                warning("Can not find Mono JIT compiler. check SystemRequirements.")
                return()
            }
        }
        
        if (!file.exists(exe)){
            warning("rawR.exe is not availble.")
            return (FALSE)
        }
        
        # execute Assembly
        rvs <-  "?"
        if (Sys.info()['sysname'] %in% c("Darwin", "Linux")){
            rvs <- system2(Sys.which('mono'), args = c(shQuote(exe)), stdout = TRUE)
        }else{
            rvs <- system2(exe, stdout = TRUE)
        }
        
        # expect that string
        if (rvs != "No RAW file specified!"){
            warning("Mono JIT compiler and rawR.exe assembly are not working.")
            return (FALSE)
        }
        
        TRUE
    }

#' Test if object is instance of class \code{rawRspectrum}
#'
#' @param x object to be tested
#'
#' @return TRUE or FALSE
#' @export is.rawRspectrum
#'
#' @examples
#' 
#' pathToRawFile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw')
#' S <- readSpectrum(pathToRawFile, scan = 1:10)
#' is.rawRspectrum(S[[1]])
is.rawRspectrum <- function(x){
    class(x) == "rawRspectrum"
}



#' read file header Information
#'
#' @param rawfile the name of the Thermo Fisher Scietific raw file
#' @param mono enviroment
#' @param exe path of the executable.
#' @param mono_path default.
#' @param argv arguments, default.
#' @param system2_call system2 call, default.
#' @param method instrument vendor
#' @description The function extracts meta information from a given rawfile.
#' @author Tobias Kockmann and Christian Panse 2018, 2019, 2020.
#' @references Thermo Fisher NewRawfileReader C# code snippets
#' \url{https://planetorbitrap.com/rawfilereader}.
#' 
#' @seealso \link[rawDiag]{read.raw.info}
#' 
#' @return a list object containing the following entries: RAW file version,
#' Creation date, Operator, Number of instruments, Description,
#' Instrument model, Instrument name, Serial number, Software version,
#' Firmware version, Units, Mass resolution, Number of scans,
#' Number of ms2 scans, Scan range, Time range, Mass range,
#' Scan filter (first scan), Scan filter (last scan), Total number of filters,
#' Sample name, Sample id, Sample type, Sample comment, Sample vial,
#' Sample volume, Sample injection volume, Sample row number,
#' Sample dilution factor, or Sample barcode.
#' 
#' @export readFileHeader
#'
#' @examples
#' (rawfile <- file.path(path.package(package = 'rawR'), 'extdata',
#'   'sample.raw'))
#' 
#' M <- readFileHeader(rawfile)
readFileHeader <- function(rawfile,
   mono = if(Sys.info()['sysname'] %in% c("Darwin", "Linux")) TRUE else FALSE,
   exe = file.path(path.package(package = "rawR"), "exec", "rawR.exe"),
   mono_path = "",
   argv = "infoR",
   system2_call = TRUE,
                           method = "thermo"){

    if (!file.exists(rawfile)){
        stop(paste0('file ', rawfile, ' is not available. return.'))
    }
    if (!.isMonoAssemblyWorking()){
        stop('the mono assembly are not available.')
    }
    if(system2_call && method == 'thermo'){
        
        tf <- tempfile(fileext = '.R')
        tf.err <- tempfile(fileext = '.err')
        
        # message(paste("system2 is writting to tempfile ", tf, "..."))
        
        if (mono){
            rvs <- system2("mono", args = c(exe, shQuote(rawfile
            ), argv),
            stdout = tf)
        }else{
            rvs <- system2(exe, args = c(shQuote(rawfile
            ), argv),
            stderr = tf.err,
            stdout = tf)
        }
        
        if (rvs == 0){
            
            rv <- try({
                e <- new.env();
                e$info <- list()
                source(tf, local=TRUE)
                
                #message(paste("unlinking", tf, "..."))
                #unlink(tf)
                return(e$info)
            }, NULL)
            
            # unlink(tfstdout)
            return(rv)
        }
    }
    NULL
}

#' Read scan index
#'
#' @param rawfile the name of the Thermo Fisher Scietific raw file.
#' @param tmpdir a non-empty character vector giving the directory name; default
#' uses \code{tempdir()}.
#'
#' @return returns a \code{data.frame} with the column names
#' scanType, rtinseconds, precursorMass, and charge of all spectra.
#' @export readIndex
#' @importFrom utils read.csv
#' @author Tobias Kockmann and Christian Panse <cp@fgz.ethz.ch>, 2020
#' @seealso \link[rawDiag]{read.raw}
#'
#' @examples
#' (rawfile <- file.path(path.package(package = 'rawR'), 'extdata',
#'   'sample.raw'))
#'   
#' Idx <- readIndex(rawfile)
#' table(Idx$scanType)
#' plot(Idx$rtinseconds, Idx$precursorMass, col=as.factor(Idx$charge), pch=16)
readIndex <- function(rawfile, tmpdir=tempdir()){
    mono <- if(Sys.info()['sysname'] %in% c("Darwin", "Linux")) TRUE else FALSE
    exe <- file.path(path.package(package = "rawR"), "exec", "rawR.exe")
    
    if (!file.exists(rawfile)){
        stop(paste0('file ', rawfile, ' is not available. return.'))
    }

    if (!.isMonoAssemblyWorking()){
        stop('the mono assembly are not available.')
    }
    
    tfi <- tempfile(tmpdir=tmpdir)
    tfo <- tempfile(tmpdir=tmpdir)
    tfstdout <- tempfile(tmpdir=tmpdir)
    
    cmd <- exe
    
    if (mono){
        rvs <- system2(Sys.which("mono"),
                       args = c(shQuote(exe), shQuote(rawfile),
                                "index", shQuote(tfstdout)),
                       stdout=tfstdout)
    }else{
        rvs <- system2(exe,
                       args = c( shQuote(rawfile), "index", shQuote(tfstdout)),
                       stdout=tfstdout)
    }
    
    DF <- read.csv(tfstdout, header = TRUE, comment.char = "#")
    
    unlink(c(tfi, tfo, tfstdout))
    DF
}

#' Read a Set of Spectra
#'
#' @param rawfile the name of the Thermo Fisher Scietific raw file.
#' @param scan a vector of requested scan numbers. 
#' @param tmpdir a non-empty character vector giving the directory name; default
#' uses \code{tempdir()}.
#' @param validate boolean default is \code{FALSE}.
#' @author Tobias Kockmann and Christian Panse <cp@fgz.ethz.ch> 2018, 2019, 2020
#' 
#' @description the function derives spectra of a given rawfile and a given 
#' vector of scan numbers.
#'  
#'  
#' @details 
#' 
#' {\code{sample.raw}}
#' The binary example file sample.raw contains 574 fourier-transformed orbi trap
#' spectra (FTMS) recorded on a Thermo Fisher Scientific Q Exactive HF-X. The
#' mass spectrometer was operated in line with a nano electrospray source (NSI)
#' in positive mode (+). All spectra were written to disk after applying
#' centroiding (c) and lock mass correction. Additional raw data for
#' demonstration and extended testing is available through the
#' \href{tartare package}{https://bioconductor.org/packages/tartare/}.
#' \strong{Lions love raw meat!}
#' 
#' @aliases readSpectrum plot.rawRSpectrum rawR sample.raw
#' 
#' @export readSpectrum
#' @exportClass rawRspectrum
#' @exportS3Method plot rawRspectrum
#' @exportS3Method print rawRspectrum
#' @exportS3Method summary rawRspectrum
#' 
#' @return a nested list of \code{rawRspectrum} objects containing more than 50 
#' values of scan information, e.g., the charge state, two vectors containing
#' the mZ and its corresponding intensity values or the AGC information, 
#' mass calibration, ion optics \ldots
#' 
#' @seealso \link[rawDiag]{readScans}
#' 
#' @examples
#' (rawfile <- file.path(path.package(package = 'rawR'), 'extdata',
#'   'sample.raw'))
#' 
#' S <- readSpectrum(rawfile, scan = 1:9)
#' 
#' S[[1]]
#' 
#' names(S[[1]])
#' 
#' plot(S[[1]])
#' 
#'  
#' \dontrun{
#' # INPUT:
#' GAG <- "GAGSSEPVTGLDAK"
#' rawfile <- file.path(Sys.getenv("HOME"),
#'   "Downloads/20180220_14_autoQC01.raw")
#' 
#' # list spectra metainformation
#' IDX <- readIndex(rawfile)
#' 
#' # determine precursor matches
#' S <- readSpectrum(rawfile,
#'   which(abs((1.008 + (protViz::parentIonMass(GAG) - 1.008) / 2) - IDX$precursorMass) < 0.001))
#' 
#' # query spectra with precursor matches
#' rv <-lapply(S, function(x){protViz::psm(GAG, x, plot=FALSE)})
#' 
#' # determine spectra indices having the  max number of hits hits
#' hit.max <- max(hits <- sapply(rv, function(x){sum(abs(x$mZ.Da.error) < 0.01)}))
#' 
#' # take the 1st one
#' idx <- which(hits == hit.max)[1]
#' 
#' # OUTPUT
#' rv <- protViz::peakplot(GAG,  (S[[idx]]), FUN=function(b,y){cbind(b=b, y=y)})
#' # https://www.proteomicsdb.org/use/
#' cat(paste(S[[idx]]$mZ[rv$idx], "\t", S[[idx]]$intensity[rv$idx]), sep = "\n")
#' }
#' @references \itemize{
#'   \item{Thermo Fisher NewRawfileReader C# code snippets
#'     \url{https://planetorbitrap.com/rawfilereader}}.
#'   \item{\url{https://doi.org/10.5281/zenodo.2640013}}
#'   \item{the R function 1st appeared in 
#'     \url{https://doi.org/10.1021/acs.jproteome.8b00173}.
#'   }
#' }
readSpectrum <- function(rawfile, scan = NULL, tmpdir=tempdir(), validate=FALSE){
    mono <- if(Sys.info()['sysname'] %in% c("Darwin", "Linux")) TRUE else FALSE
    exe <- file.path(path.package(package = "rawR"), "exec", "rawR.exe")
    
    
    if (!file.exists(rawfile)){
        stop(paste0('file ', rawfile, ' is not available. return.'))
    }
    if (is.null(scan)){
        stop('no scan vector is proived.')
    }
    if (!.isMonoAssemblyWorking()){
        stop('the mono assembly are not available.')
    }
    
    tfi <- tempfile(tmpdir=tmpdir)
    tfo <- tempfile(tmpdir=tmpdir)
    tfstdout <- tempfile(tmpdir=tmpdir)
    
    cat(scan, file = tfi, sep="\n")
    
    cmd <- exe
    
    if (mono){
        rvs <- system2(Sys.which("mono"), args = c(shQuote(exe), shQuote(rawfile),
                                                   "scans", shQuote(tfi), shQuote(tfo)))
    }else{
        rvs <- system2(exe, args = c( shQuote(rawfile), "scans", shQuote(tfi),
                                      shQuote(tfo)))
    }
    
    e <- new.env()
    
    source(tfo, local=TRUE)
    unlink(c(tfi, tfo, tfstdout))
    
    
    rv <- lapply(e$Spectrum,
                 function(x){class(x) <- c('rawRspectrum'); x})
    if(validate){
        rv <- lapply(rv, validate_rawRspectrum)
    }
    
    rv
}


#' Extracts Chromatograms
#'
#' @param rawfile the file name. 
#' @param mass a vector of mass values iff \code{type = 'xic'}. 
#' @param tol mass tolerance in ppm iff \code{type = 'xic'}.
#' @param filter defines the scan filter, default is \code{filter="ms"} if a
#' wrong filter is set the function will return \code{NULL} and draws a warning.
#' @param type \code{c(xic, bpc, tic)} for extracted ion , base peak or
#' total ion chromatogram.
#' @param mono if the mono enviroment should be used. 
#' @param exe the exe file user by mono.
#' 
#' @seealso Thermo Fisher NewRawfileReader C# code snippets
#' \url{https://planetorbitrap.com/rawfilereader}.
#' 
#' @return chromatogram object(s) containing of a vector of \code{times} and a
#' corresponding vector of \code{intensities}.
#' 
#' @references
#' \itemize{
#'   \item{\url{https://doi.org/10.5281/zenodo.2640013}}
#'   \item{the R function 1st appeared in
#'     \url{https://doi.org/10.1021/acs.jproteome.8b00173}}
#' }
#' 
#' @author Christian Trachsel, Tobias Kockmann and
#' Christian Panse <cp@fgz.ethz.ch> 2018, 2019, 2020.
#' @seealso \link[rawDiag]{readXICs}
#' @export readChromatogram 
#' @exportClass rawRchromatogram
#' @exportClass rawRchromatogramSet
#' @exportS3Method plot rawRchromatogram
#' @exportS3Method plot rawRchromatogramSet
#' @examples
#' 
#' # Example 1: not meaning full but proof-of-concept
#' (rawfile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw'))
#' 
#' XIC <- readChromatogram(rawfile, mass=c(669.8381, 726.8357), tol=1000)
#' plot(XIC)
#' 
#' BPC <- readChromatogram(rawfile, type='bpc')
#' plot(BPC)
#' 
#' TIC <- readChromatogram(rawfile, type='tic')
#' plot(TIC)
#' 
#' # Example 2: extract iRT peptides
#' iRTpeptide <- c("LGGNEQVTR", "YILAGVENSK", "GTFIIDPGGVIR", "GTFIIDPAAVIR",
#'   "GAGSSEPVTGLDAK", "TPVISGGPYEYR", "VEATFGVDESNAK",
#'   "TPVITGAPYEYR", "DGLDAASYYAPVR", "ADVTPADFSEWSK",
#'   "LFLQFGAQGSPFLK")
#' 
#' # [2H+] 
#' if (require(protViz)){
#'      (mZ <- (parentIonMass(iRTpeptide) + 1.008) / 2)
#'   }else{
#'      message("consider installing  https://CRAN.R-project.org/package=protViz")
#' }
#'
#' \dontrun{
#' # https://fgcz-ms.uzh.ch/p2692/Proteomics/QEXACTIVEHFX_1/tobiasko_20180220_scanSpeed/20180220_14_autoQC01.raw
#' # md5 = 00ffee77b82202200e5aec0522729f51
#' 
#' rawfile <- file.path(Sys.getenv('HOME'), "Downloads", "20180220_14_autoQC01.raw")
#' X <- readChromatogram(rawfile, mZ)
#' }
#' 
readChromatogram <- function(rawfile,
                             mass = NULL,
                             tol = 10,
                             filter = "ms",
                             type = 'xic',
                             mono = if(Sys.info()['sysname'] %in% c("Darwin", "Linux")) TRUE else FALSE,
                             exe = file.path(path.package(package = "rawR"), "exec", "rawR.exe")){
    
    if (!file.exists(rawfile)){
        stop(paste0('file ', rawfile, ' is not available. return.'))
    }
    
    if (!.isMonoAssemblyWorking()){
        stop('the mono assembly are not available.')
    }
    
    tfstdout <- tempfile()
    tfi <- tempfile()
    tfo <- tempfile()
    if(type == 'xic'){
        if (is.null(mass)){
            stop('no mass vector is proived.')
        }
        cat(mass, file=tfi, sep="\n")
        
        cmd <- exe
        
        if (mono){
            rvs <- system2("mono", args = c(shQuote(exe), shQuote(rawfile), "xic",
                                            shQuote(tfi), tol, shQuote(tfo), shQuote(filter)))
        }else{
            rvs <- system2(exe, args = c(shQuote(rawfile), "xic", shQuote(tfi), tol,
                                         shQuote(tfo), shQuote(filter)))
        }
        
        rv <- try({
            e <- new.env();
            e$chromatogram <- list()
            source(tfo, local = TRUE)
            
            
            if ('warning' %in% names(e)){
                warning(e$warning)
            }
            
            if ('message' %in% names(e)){
                message(e$message)
            }
            
            if ('error' %in% names(e)){
                warning(e$error)
                return(NULL)
            } 
            
            e$chromatogram
        }, NULL)
        
        
        #message(paste(c(tfi, tfo, tfstdout), collapse = ",\n"))
        #message(length(rv))
        rv <- lapply(rv,
                     function(x){
                         attr(x , 'filename') <- rawfile
                         attr(x, 'type') <- 'xic'
                         class(x) <- 'rawRchromatogram';
                         x})
        
    }else{
        if (mono){
            rvs <- system2("mono", args = c(shQuote(exe), shQuote(rawfile), "chromatogram", shQuote(filter)), stdout=tfstdout)
        }else{
            rvs <- system2(exe, args = c(shQuote(rawfile), "chromatogram",  shQuote(filter)),stdout=tfstdout)
        }
        DF <- read.csv(tfstdout, header = TRUE, comment.char = "#")
        
        
        if (type == 'tic'){
            rv <- list(
                times=DF$rt,
                intensities=DF$intensity.TIC)
        }else{
            # expect bpc
            rv <- list(times=DF$rt,
                       intensities=DF$intensity.BasePeak)
        }
    }
    unlink(c(tfi, tfo, tfstdout))
    
    attr(rv, 'filter') <- filter
    attr(rv, 'filename') <- rawfile
    
    if (type=='xic'){
        attr(rv, 'type') <- 'xic'
        attr(rv, 'tol') <- tol
        class(rv) <- 'rawRchromatogramSet'
    }else if (type=='tic'){
        attr(rv, 'type') <- 'tic'
        class(rv) <- 'rawRchromatogram'
    }else{
        attr(rv, 'type') <- 'bpc'
        class(rv) <- 'rawRchromatogram'
    }
    
    rv
}


#' Create instances of class \code{rawRspectrum}
#' 
#' Developer function.
#'
#' @param scan scan number
#' @param massRange Mass range covered by spectrum
#' @param scanType Character string describing the scan type.
#' @param rtinseconds Retention time in seconds
#' @param centroidStream Logical indicating if centroided data is available
#' @param mZ m/z values
#' @param intensity Intensity values
#'
#' @return Object of class \code{rawRspectrum}
#' @export new_rawRspectrum
#'
#' @examples
new_rawRspectrum <- function(scan = numeric(), massRange = numeric(),
                             scanType = character(), rtinseconds = numeric(),
                             centroidStream = logical(),
                             mZ = numeric(), intensity = numeric()){
    
    stopifnot(is.numeric(scan), is.numeric(massRange), is.character(scanType),
              is.numeric(rtinseconds), is.logical(centroidStream),
              is.numeric(mZ), is.numeric(intensity)
    )
    
    structure(list(scan = scan,
                   basePeak = c(mZ[which.max(intensity)], intensity[which.max(intensity)]),
                   TIC = sum(intensity), massRange = massRange,
                   scanType = scanType, rtinseconds = rtinseconds,
                   centroidStream = centroidStream,
                   mZ = mZ, intensity = intensity),
              class = "rawRspectrum")

}

#' Create \code{rawRspectrum} objects
#' 
#' @description High-level constructor for instances of class
#' \code{rawRspectrum}, also named helper function. Currently, mainly to support
#' testing and for demonstration.
#' 
#'
#' @param sim Either \code{example_1} or \code{TESTPEPTIDE}
#'
#' @return Function returns a validated \code{rawRspectrum} object
#' @export rawRspectrum
#'
#' @examples
#' 
#' plot(rawRspectrum(sim = "TESTPEPTIDE"))
#' rawRspectrum(sim = "example_1")
#' 
#' @author Tobias Kockmann, 2020.
rawRspectrum <- function(sim = character()) {
    
    stopifnot(is.character(sim))
    
    if (sim == "example_1") {
        S <- new_rawRspectrum(scan = 1,
                              massRange = c(90, 1510),
                              rtinseconds = 1,
                              scanType = "simulated",
                              centroidStream = FALSE,
                              mZ = 1:15*100,
                              intensity = rep(100, times = 15)
                              )
    }
    
    if (sim == "TESTPEPTIDE") {
        S <- new_rawRspectrum(scan = 1,
                              massRange = c(90, 1510),
                              rtinseconds = 1,
                              scanType = "simulated",
                              centroidStream = FALSE,
                              mZ = c(148.0604, 263.0874, 376.1714, 477.2191,
                                     574.2719, 703.3145, 800.3672, 901.4149,
                                     988.4469, 1117.4895),
                              intensity = rep(100, times = 10)
        )
        
    }
    
    ## more examples?
    
    validate_rawRspectrum(S)
    
}

#' Validate instance of class rawRSpectrum 
#'
#' @description Checks the validity of \code{rawRspectrum} object attributes. 
#'
#' @param x object to be validated.
#'
#' @usage validate_rawRspectrum(x)
#' 
#' @return Validated \code{rawRspectrum} object
#' @export validate_rawRspectrum
validate_rawRspectrum <- function(x){
    values <- unclass(x)
    
    if (values$scan < 1) {
        stop("Scan values just be >= 1", call. = FALSE)
    }
    
    if (length(values$mZ) != length(values$intensity)){
        stop(
            "mZ should have same length as intensities.",
            call. = FALSE
        )
    }
    
    if (any(values$mZ < 0)) {
        stop("All mZ values just be greater than zero", call. = FALSE)
    }
    
    if (any(values$intensity < 0)) {
        stop("All intensity values just be greater than zero", call. = FALSE)
    }
    
    if (any(values$massRange < 0)) {
        stop("All massRange values just be greater than zero", call. = FALSE)
    }
    
    if (values$massRange[1] > values$massRange[2]) {
        stop("massRange[1] must be smaller than massRange[2].", call. = FALSE)
    }
    
    if (any(values$basePeak < 0)) {
        stop("All basePeak values must be greater than zero.", call. = FALSE)
    }
    
    ## still problems here: fails with sample data
    
    if (!values$basePeak[1] %in% values$mZ) {
        stop("basePeak[1] (position) must be found in mZ", call. = FALSE)
    }
    
    if (values$basePeak[2] != max(values$intensity)) {
        stop("basePeak intensity is unequal max. intensity", call. = FALSE)
    }
    
    ##
    
    if (values$rtinseconds < 0) {
        stop("rtinseconds must be greater than zero", call. = FALSE)
    }
    
    x
}

#' Basic plotting function for instances of \code{rawRspectrum}
#'
#' \code{plot.rawRspectrum} is a low level function that calls
#' \code{base::plot} for plotting \code{rawRspectrum} objects. It passes all
#' additional arguments to \code{plot()}
#'
#' @description Plot method for objects of class \code{rawRspectrum}.
#' @details Is usually called by method dispatch.
#'
#' @param x an object of class \code{rawRspectrum}.
#'
#' @param relative If set to \code{TRUE} enforces plotting of relative
#' intensities rather than absolute.
#' 
#' @param centroid Should centroided data be used for plotting?
#' 
#' @param SN Should Signal/Noise be used for plotting?
#' 
#' @param legend Should legend be printed?
#' @param diagnostic Should this option be applied? The default is \code{FALSE}.
#' @param ... function passes arbitrary additional arguments.
#' @author Tobias Kockmann, 2020
#' @importFrom graphics legend
plot.rawRspectrum <- function(x, relative = TRUE, centroid = FALSE, SN = FALSE,
                              legend = TRUE, diagnostic = FALSE, ...){
    
    stopifnot(is.rawRspectrum(x))
    
    if (centroid) {
        
        stopifnot(x$centroidStream)
        
        if (SN) {
            
            plot(x = x$centroid.mZ, y = x$centroid.intensity/x$noise,
                 type = "h",
                 xlim = x$massRange,
                 xlab = "Centroid m/z",
                 ylab = "Centroid Signal/Noise",
                 frame.plot = FALSE, ...
            )
            
        } else {
            
            plot(x = x$centroid.mZ, y = x$centroid.intensity,
                 type = "h",
                 xlim = x$massRange,
                 ylim = c(0, 1.2 *  max(x$centroid.intensity)),
                 xlab = "Centroid m/z",
                 ylab = "Centroid Intensity",
                 frame.plot = FALSE, ...
            )
            if (all(c('charges', 'resolutions') %in% names(x))){
                # ylim = c(0, 1.1*max(x$ x$centroid.intensity))
                # TODO(cp): label top 10 with z=, R=
                n <- length(x$centroid.intensity)
                if (n > 10) n <- 10
                i  <- order(x$centroid.intensity, decreasing = TRUE)[1:n]
                
                
                text(x = x$centroid.mZ[i],
                     y = x$centroid.intensity[i],
                     pos = 3,
                     labels = paste(format(x$centroid.mZ[i], nsmall = 4),
                                    "\nz = ", x$charges[i], "\nR = ",
                                    x$resolutions[i]),
                     cex = 0.5)
            }
            
        }
        
        
    } else {
        
        if (relative) {
            
            plot(x = x$mZ, y = x$intensity/x$basePeak[2], type = "h",
                 xlim = x$massRange,
                 xlab = "m/z",
                 ylab = "Relative Intensity",
                 frame.plot = FALSE, ...)
            
        } else {
            
            plot(x = x$mZ, y = x$intensity, type = "h",
                 xlim = x$massRange,
                 xlab = "m/z",
                 ylab = "Intensity",
                 frame.plot = FALSE, ...)
            
        }
        
    }
    
    
    if (legend) {
        
        #basePeak <- paste("(", paste(format(x$basePeak, nsmall = 4),
        #                             collapse = ", "), ")", sep='')
        legend("topleft",
               paste(c("Scan#: ",
                       "Scan Type: ",
                       "RT [s]: ",
                       "Base peak mass [m/z]: ",
                       "Base peak intensity: ",
                       "TIC: "),
                     c(x$scan,
                       x$scanType,
                       x$rtinseconds,
                       format(x$basePeak[1], nnsmall = 4),
                       format(x$basePeak[2], scientific = TRUE),
                       format(x$TIC, scientific = TRUE))
                     ),
               bty = "n",
               cex=0.5)
        
    }
    
    if (diagnostic) {
        legend("left", legend = paste(c("Injection time [ms]: ",
                                          "Max. Injection time [ms]: ",
                                          "AGC target: ",
                                          "Resolution: "),
                                        c(x$`Ion Injection Time (ms)`,
                                          x$`Max. Ion Time (ms)`,
                                          x$`AGC Target`,
                                          x$`FT Resolution`)),
               bty = "n", cex = 0.75, text.col = "grey")
    }

}

#' Basic summary function
#' @author Christian Panse & Tobias Kockmann, 2020
#' @param object an \code{rawRspectrum} object.
#' @param \ldots Arguments to be passed to methods.
summary.rawRspectrum <- function(object, ...){
    cat("Total Ion Current:\t", object$TIC, fill = TRUE)
    cat("Scan Low Mass:\t", object$massRange[1], fill = TRUE)
    cat("Scan High Mass:\t", object$massRange[2], fill = TRUE)
    cat("Scan Start Time (Min):\t", round(object$rtinseconds/60,2), fill = TRUE)
    cat("Scan Number:\t", object$scan, fill=TRUE)
    cat("Base Peak Intensity:\t", object$basePeak[2], fill = TRUE)
    cat("Base Peak Mass:\t", object$basePeak[1], fill = TRUE)
    cat("Scan Mode:\t", object$scanType, fill = TRUE)
}

#' Basic print function faking the look and feel of freestyle's output 
#' @author Christian Panse & Tobias Kockmann, 2020
#' @param x an \code{rawRspectrum} object.
#' @param \ldots Arguments to be passed to methods.
print.rawRspectrum <- function(x, ...){
    cat("Total Ion Current:\t", x$TIC, fill = TRUE)
    cat("Scan Low Mass:\t", x$massRange[1], fill = TRUE)
    cat("Scan High Mass:\t", x$massRange[2], fill = TRUE)
    cat("Scan Start Time (Min):\t", round(x$rtinseconds/60,2), fill = TRUE)
    cat("Scan Number:\t", x$scan, fill=TRUE)
    cat("Base Peak Intensity:\t", x$basePeak[2], fill = TRUE)
    cat("Base Peak Mass:\t", x$basePeak[1], fill = TRUE)
    cat("Scan Mode:\t", x$scanType, fill = TRUE)

    keys <- c("======= Instrument data =====   :",
              "Multiple Injection:",
              "Multi Inject Info:",
              "AGC:",
              "Micro Scan Count:",
              "Scan Segment:",
              "Scan Event:",
              "Master Index:",
              "Charge State:",
              "Monoisotopic M/Z:",
              "Ion Injection Time (ms):",
              "Max. Ion Time (ms):",
              "FT Resolution:",
              "MS2 Isolation Width:",
              "MS2 Isolation Offset:",
              "AGC Target:",
              "HCD Energy:",
              "Analyzer Temperature:",
              "=== Mass Calibration:",
              "Conversion Parameter B:",
              "Conversion Parameter C:",
              "Temperature Comp. (ppm):",
              "RF Comp. (ppm):",
              "Space Charge Comp. (ppm):",
              "Resolution Comp. (ppm):",
              "Number of Lock Masses:",
              "Lock Mass #1 (m/z):",
              "Lock Mass #2 (m/z):",
              "Lock Mass #3 (m/z):",
              "LM Search Window (ppm):",
              "LM Search Window (mmu):",
              "Number of LM Found:",
              "Last Locking (sec):",
              "LM m/z-Correction (ppm):",
              "=== Ion Optics Settings:",
              "S-Lens RF Level:",
              "S-Lens Voltage (V):",
              "Skimmer Voltage (V):",
              "Inject Flatapole Offset (V):",
              "Bent Flatapole DC (V):",
              "MP2 and MP3 RF (V):",
              "Gate Lens Voltage (V):",
              "C-Trap RF (V):",
              "====  Diagnostic Data:",
              "Dynamic RT Shift (min):",
              "Intens Comp Factor:",
              "Res. Dep. Intens:",
              "CTCD NumF:",
              "CTCD Comp:",
              "CTCD ScScr:",
              "RawOvFtT:",
              "LC FWHM parameter:",
              "Rod:",
              "PS Inj. Time (ms):",
              "AGC PS Mode:",
              "AGC PS Diag:",
              "HCD Energy eV:",
              "AGC Fill:",
              "Injection t0:",
              "t0 FLP:",
              "Access Id:",
              "Analog Input 1 (V):",
              "Analog Input 2 (V):"
    )
    for (i in keys){
        value <- x[i]
       
        if (value == "NULL"){
            cat(i, "\t\n", fill = TRUE)
        }else{
            cat(paste(i, x[i],sep='\t'), fill = TRUE) 
        }
    }
}

#' Check if object is instance of class \code{rawRchromatogram}
#'
#' @param x The object to be tested.
#'
#' @usage is.rawRchromatogram(x)
#'
#' @return Boolean
#' @export is.rawRchromatogram
#'
#' @examples pathToRawFile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw')
#' C <- readChromatogram(pathToRawFile, mass = 445.1181, tol = 10)
#' is.rawRchromatogram(C[[1]])
is.rawRchromatogram <- function(x){
    "rawRchromatogram" %in% class(x)
}

#' Plot \code{rawRchromatogram} objects
#'
#' @param x A \code{rawRchromatogram} object to be plotted.
#' @param legend Should legend be printed?
#' @param ... Passes additional arguments.
#'
#' @export plot.rawRchromatogram
#'
#' @examples pathToRawFile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw')
#' C <- readChromatogram(pathToRawFile, mass = 445.1181, tol = 10)
#' plot(C[[1]])
plot.rawRchromatogram <- function(x, legend = TRUE, ...){
    stopifnot(is.rawRchromatogram(x))
    
    plot(x = x$times, y = x$intensities,
         xlab = "Retention Time [min]",
         ylab = "Intensity",
         type = "l",
         frame.plot = FALSE)
    
    
    if (legend) {
        if(attr(x, 'type') == 'xic'){
            legend("topleft",
                   legend = paste(c("File: ", "Filter: ", "Mass: ", "Tolerance: "),
                                  c(basename(attr(x, 'filename')), 
                                    x$filter, 
                                    x$mass,
                                    x$ppm)
                   ),
                   bty = "n",
                   title = toupper(attr(x, 'type')),
                   cex = 0.75)
        }else{
            legend("topleft",
                   legend = paste(c("File:"), c(basename(attr(x, 'filename')))),
                   bty = "n",
                   title = toupper(attr(x, 'type')),
                   cex = 0.75)
        }
    }
}

#' Plot \code{rawRchromatogramSet} objects
#'
#' @param x A \code{rawRchromatogramSet} object to be plotted.
#' @param ... Passes additional arguments.
#' @param diagnostic Show diagnostic legend?
#' 
#' @export plot.rawRchromatogramSet
#' @importFrom grDevices hcl.colors
#' @importFrom graphics lines text
plot.rawRchromatogramSet <- function(x, diagnostic = FALSE, ...){
    
    #should become is.Class function in the future
    stopifnot(attr(x, "class") == "rawRchromatogramSet")
    
    ## so far only XIC branch available
    
    if (attr(x, 'type') == 'xic') {
        plot(0, 0, type='n',
             xlim=range(unlist(lapply(x, function(o){o$times}))),
             ylim=range(unlist(lapply(x, function(o){o$intensities}))),
             frame.plot = FALSE,
             xlab='Retention Time [min]',
             ylab='Intensities', ...
        )
        
        cm <- hcl.colors(length(x), "Set 2")
        mapply(function(o, co){lines(o$times, o$intensities, col=co)}, x, cm)
        legend("topleft",
               as.character(sapply(x, function(o){o$mass})),
               col=cm,
               pch=16, 
               title='target mass [m/z]',
               bty='n', cex = 0.75)
    
        if (diagnostic) {
            legend("topright", legend = paste(c("File: ",
                                                "Filter: ",
                                                "Type: ",
                                                "Tolerance: "
                                          ),
                                          c(basename(attr(x, "file")),
                                            attr(x, "filter"),
                                            attr(x, "type"),
                                            attr(x, "tol")
                                          )
                                    ),
                   bty = "n", cex = 0.75, text.col = "black")    
        }
    }
}

#' A sparse vector representation of \code{rawRspectrum}
#'
#' @param x A \code{rawSpectrum} object
#' @param binSize Bin size along m/z dimension used to aggregate centroided intensity values.
#' @param fun Function used for aggregation of signals within bins.
#' @param StoNcutoff A S/N cutoff applied for peak filtering 
#' @param vType Either \code{sV} for a sparse vector,
#' \code{scV} for a sparse column vector (matrix type),
#' or \code{srV} for a sparse row vector (matrix type).
#' 
#' @author Tobias Kockmann
#'
#' @description Function converts the centroided peak information stored in a
#' \code{rawRspectrum} object into a sparse vector/matrix representation. This is
#' primarily useful for spectrum vs. spectrum comparisons that rely on vector
#' arithmetics like dot product. Since centroided data can be very sparse, we
#' chose to use sparse instead of dense vectors/matrises.
#' 
#' @details The input spectrum is divided into m/z bins of equal size (see binSize parameter)
#' and each bin is assigned a certain weight, calculated by using an aggregation function
#' (see fun parameter). Typically \code{sum} or \code{max} are used. The binned spectrum is
#' than converted into a sparse vector. The i index of none zero values goes
#' along the m/z bins.
#'
#' @return A sparse object depending on \code{vType}
#' @export as_sparseVector
#'
#' @examples pathToRawFile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw')
#' I <- readIndex(pathToRawFile)
#' S <- readSpectrum(pathToRawFile, 1:dim(I)[1])
#' sV <- lapply(S[I[I$MSOrder == "Ms", "scan"]], as_sparseVector)
#' plot(sV[[1]], type = "h")
#' 
#' ## Generate sparse row vector
#' as_sparseVector(S[[1]], vType = "srV")
#' 
#' ## Generate sparse column vector
#' as_sparseVector(S[[1]], vType = "scV")
#'
#' ## Generate sparse vector
#' as_sparseVector(S[[1]], vType = "sV")
as_sparseVector <- function(x, binSize = 1, fun = "sum", StoNcutoff = 3,
                            topN = 100, vType = "srV", peakFilter = "StoN"){

 ## TODO : add option to subset on S/N [x]
 ## TODO : add possibility to subset on order/rank, topN []
     
    stopifnot(is.rawRspectrum(x), is.numeric(binSize), is.numeric(StoNcutoff),
              is.numeric(topN), is.character(vType), is.character(peakFilter))
    
    if (x$centroidStream) {
        
        ## 1. org. centroided data
        df <- data.frame(pos = x$centroid.mZ,
                        int = x$centroid.intensity,
                        z = x$charges,
                        n = x$noises,
                        r = x$resolutions,
                        b = x$baselines,
                        bin = x$centroid.mZ %/% binSize,
                        sn = x$centroid.intensity/x$noises,
                        rint = x$centroid.intensity/max(x$centroid.intensity),
                        order = order(x$centroid.intensity/x$noises, decreasing = FALSE))
        
        message("The original centroided data:")
        print(head(df))
        
        ## 2. filtering
        if (peakFilter == "StoN") {
            
            ## subsetting on S/N
            message(paste("Subsetting with S/N cutoff:", StoNcutoff, sep = " "))
            df <- df[df$sn > StoNcutoff, ]
            print(head(df))
            
        } else {
            
            if (peakFilter == "topN") {
                
                message("Not implemented yet!")
                
            }
            
        }
        
        ## 3. aggregation
        message(paste("Aggregating peaks in", binSize, "m/z bins by", fun, sep = " "))
        df <- aggregate(int ~ bin, data = df, FUN = fun)
        print(head(df))
        
        ## 4. sparse vector creation
        switch (vType,
            sV = {
                
                ## sparse vector
                message(paste("Generating sparse vector for m/z interval [",
                              0, ",", x$massRange[2], "]"))
                sV <- Matrix::sparseVector(x = df$int,
                                           i = df$bin,
                                           length = x$massRange[2]/binSize)
                return(sV)
                
            },
            scV = {
                
                ## sparse column vector
                message(paste("Generating sparse column vector for m/z interval [",
                              0, ",", x$massRange[2], "]"))
                scM <- Matrix::sparseMatrix(x = df$int,
                                            i = df$bin,
                                            j = rep(1, length(df$int)),
                                            dims = c(x$massRange[2]/binSize, 1))
                return(scM)
                
            },
            srV = {
                
                ## a sparse row vector
                message(paste("Generating sparse row vector for m/z interval [",
                              0, ",", x$massRange[2], "]"))
                srM <- Matrix::sparseMatrix(x = df$int,
                                            i = rep(1, length(df$int)),
                                            j = df$bin,
                                            dims = c(1, x$massRange[2]/binSize))
                return(srM)
                
            },
            stop("Invalid vType!")
        )
        
    } else {
        
        stop("The rawRspectrum instance does not contain a centroided stream!")
    
      }
}


#' The normalized dot product of two sparse vectors
#'
#' @author Tobias Kockmann
#' @description The function calculates the normalized dot product of two sparse
#' vectors given they are of equal dimentionality (length). The normalized dot
#' product is also called the cosine distance between two vectors.
#' 
#' @details See Eq. 6 of Yilmaz Ş, Vandermarliere E, Martens L.
#' Methods to Calculate Spectrum Similarity. Methods Mol Biol. 2017;1549:75-100.
#' doi: 10.1007/978-1-4939-6740-7_7. PMID: 27975285.
#' 
#' \deqn{ \cos\theta = \frac{\sum(x \times y)}{sqrt(\sum(x^2))sqrt(\sum(y^2))}}
#'  
#'
#' @param x A sparse vector
#' @param y A sparse vector
#'
#' @return A numeric value between 0 and 1 equal to the normalized dot product.
#' @export normDotProt
#'
#' @examples pathToRawFile <- file.path(path.package(package = 'rawR'), 'extdata', 'sample.raw')
#' sS <- as_sparseVector(readSpectrum(pathToRawFile, scan = 1)[[1]])
#' normDotProt(sS, sS)
normDotProt <- function(x, y){
    
    stopifnot(is(x, "sparseVector"), is(y, "sparseVector"), length(x) == length(y))
    
    sum(x*y)/(sqrt(sum(x^2))*sqrt(sum(y^2)))
}
